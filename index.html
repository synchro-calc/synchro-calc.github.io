<!DOCTYPE html>
<html>
    <!-- Color palette :
    background dark grey : #1E1F1B
    green : #267E08
    light gray : #757674
    very light gray (text) : #EAEBE7
-->
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=480px, initial-scale=1" />
        <title>Synchro Calculator</title>
        <style>
            :root {
                --unit: calc(min(max(min(5vh, 5vw), 40px), 100px));
                --text-medium: calc(24 / 55 * var(--unit));
                --text-small: calc(19 / 55 * var(--unit));
                --text-smaller: calc(16 / 55 * var(--unit));
                --text-big: calc(40 / 55 * var(--unit));
                --icon-width: calc(28 / 55 * var(--unit));
                --offset: calc(-3 / 55 * var(--unit));
                --border-width: calc(4 / 50 * var(--unit));
            }
            .spell-grid-container {
                width: 60%;
                display: grid;
                background-color: #1e1f1b;
                padding: 1px;
            }
            .grid-container {
                display: grid;
                background-color: #1e1f1b;
                padding: 1px;
            }
            .grid-item {
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 4px;
                border: 1px solid rgba(0, 0, 0, 0.8);
                border-radius: 5px;
                font-size: 40px;
                text-align: center;
            }
            .center-vertical {
                display: flex;
                flex-direction: row;
                align-items: center;
            }
            .grid-item > p {
                margin-top: 5%;
                margin-bottom: -5%;
            }
            .add-new > input[type='text'] {
                height: var(--text-small);
                font-size: var(--text-small);
                margin-top: 5%;
                margin-bottom: -5%;
            }
            .damageDisplay > div {
                display: flex;
                align-items: center;
                justify-content: center;
                color: black;
                font-size: var(--text-big);
            }
            .settings {
                height: calc(30 / 55 * var(--unit));
                font-size: var(--text-small);
                text-align: center;
                align-content: center;
            }
            .settings > input[type='text'] {
                height: var(--text-small);
                font-size: var(--text-smaller);
                width: var(--icon-width);
                text-align: center;
            }
            .sectionLabel {
                font-size: var(--text-medium);
            }
            input[type='range'] {
                -webkit-appearance: none;
                height: var(--border-width);
                outline: none !important;
                appearance: none;
                border: var(--border-width) solid black;
                border-radius: 30px;
            }
            input[type='range']:hover {
                outline: none;
            }
            input[type='range']::-moz-range-thumb {
                width: var(--text-smaller);
                height: var(--text-smaller);
                background: #757674;
                cursor: pointer;
                border-radius: 50%;
                border: var(--border-width) solid black;
                outline: none;
            }
            input[type='range']::-moz-range-progress {
                background-color: #757674;
                height: 100%;
                border-radius: 30px;
            }
            input[type='range']::-moz-range-track {
                background-color: #757674;
                border-radius: 30px;
                border: none;
                height: 100%;
            }

            input[type='text']:hover {
                outline: none;
            }
            input[type='text']:focus {
                outline: none;
            }
            input[type='text'] {
                border: 1px solid black;
                border-radius: 5px;
            }
        </style>
    </head>

    <body style="background-color: #1e1f1b; font-family: 'Courier New', Courier, monospace; color: #eaebe7">
        <div style="display: grid; grid-template-columns: 1fr 1fr; width: 98vw">
            <div style="display: grid; justify-items: left">
                <div
                    class="grid-container"
                    id="damageGridContainer"
                    style="grid-template-columns: 1fr 1fr; grid-template-rows: 1fr; width: calc(10 * var(--unit))"
                >
                    <div
                        class="grid-item damageDisplay"
                        id="expectedDamageParentNode-Melee"
                        style="background-color: #757674; display: grid; grid-template-columns: 1fr 2fr"
                    >
                        <img
                            src="./images/melee.png"
                            alt="[MELEE ICON]"
                            style="float: left; padding-left: 40%; width: var(--unit)"
                        />
                        <div id="expectedDamageNode-Melee">0</div>
                    </div>
                    <div
                        class="grid-item damageDisplay"
                        id="expectedDamageParentNode-Range"
                        style="background-color: #757674; display: grid; grid-template-columns: 1fr 2fr"
                    >
                        <img
                            src="./images/range.png"
                            alt="[RANGE ICON]"
                            style="float: left; padding-left: 40%; width: var(--unit)"
                        />
                        <div id="expectedDamageNode-Range">0</div>
                    </div>
                </div>
            </div>

            <div style="display: grid; justify-items: right">
                <div
                    id="localeContainer"
                    class="grid-container"
                    style="grid-template-columns: auto auto; margin-bottom: 0px"
                >
                    <div
                        id="currentLocaleCode"
                        class="grid-item"
                        style="border: 0px; font-size: var(--text-small); margin-bottom: 0px"
                    >
                        FR
                    </div>
                    <div class="grid-item" style="border: 0px; height: 18px">
                        <input
                            id="currentLocaleImageNode"
                            type="image"
                            src="./images/FR-flag.jpeg"
                            alt="[FLAG]"
                            style="float: right; margin: left 10px top 0px; width: calc(32 / 55 * var(--unit))"
                            onclick="cycleLocale()"
                        />
                    </div>
                </div>
            </div>
        </div>

        <div
            class="grid-container"
            style="width: calc(10 * var(--unit)); grid-template-columns: 1fr 1fr; grid-template-rows: auto auto auto"
        >
            <div class="settings">
                <label for="percentAirRes" id="percentAirResLabel">% Air Res</label>
                <input type="text" id="percentAirRes" oninput="updateExpectedDamage()" />
                <img
                    src="./images/Air_Resistance.png"
                    style="position: absolute; margin-top: var(--offset); width: var(--icon-width)"
                />
            </div>
            <div class="settings">
                <label for="meleeRes" id="meleeResLabel">% Melee</label>
                <input type="text" id="meleeRes" oninput="updateExpectedDamage()" />
                <img
                    src="./images/Melee_Resistance.png"
                    style="position: absolute; margin-top: var(--offset); width: var(--icon-width)"
                />
            </div>
            <div class="settings">
                <label for="fixedAirRes" id="fixedAirResLabel">Air Res</label>
                <input type="text" id="fixedAirRes" oninput="updateExpectedDamage()" />
                <img
                    src="./images/Air_Resistance.png"
                    style="position: absolute; margin-top: var(--offset); width: var(--icon-width)"
                />
            </div>
            <div class="settings">
                <label for="rangeRes" id="rangeResLabel">% Range</label>
                <input type="text" id="rangeRes" oninput="updateExpectedDamage()" />
                <img
                    src="./images/Range_Resistance.png"
                    style="position: absolute; margin-top: var(--offset); width: var(--icon-width)"
                />
            </div>
            <div class="settings"></div>
            <div class="settings"></div>
            <div>
                <div class="settings">
                    <label for="levelXel" id="levelXelLabel">&nbsp;&nbsp; Niveau</label>
                    <input
                        type="text"
                        id="levelXel"
                        oninput="updateXelorLevel()"
                        value="200"
                        style="width: calc(6 / 5 * var(--icon-width)); text-align: center"
                    />
                </div>
            </div>
            <div class="settings">
                <label for="baseDamage" id="baseDamageLabel">Dégâts de base</label>
                <input
                    type="text"
                    id="baseDamage"
                    oninput="updateBaseDamage()"
                    value="368"
                    style="width: calc(6 / 5 * var(--icon-width)); text-align: center"
                />
            </div>
            <div>
                <div class="settings">
                    <label for="powerBoost" id="powerBoostLabel">&nbsp;&nbsp; Puissance</label>
                    <input type="text" id="powerBoost" oninput="updatePowerBoost()" value="" />
                    <img
                        src="./images/puissance.png"
                        style="position: absolute; margin-top: var(--offset); width: var(--icon-width)"
                    />
                </div>
            </div>
            <div class="settings">
                <label for="damageBoost" id="damageBoostLabel">Do Fixes</label>
                <input type="text" id="damageBoost" oninput="updateDamageBoost()" value="" />
                <img
                    src="./images/do_fixes.png"
                    style="position: absolute; margin-top: var(--offset); width: var(--icon-width)"
                />
            </div>
        </div>

        <br />

        <label class="sectionLabel" for="additionalFixedReductionContainer" id="additionalFixedReductionContainerLabel"
            >Fixed Reductions</label
        >
        <div class="grid-container" id="additionalFixedReductionContainer" style="width: 0px"></div>
        <label class="sectionLabel" for="additionalFinalReductionContainer" id="additionalFinalReductionContainerLabel"
            >Final Reductions</label
        >
        <div class="grid-container" id="additionalFinalReductionContainer" style="width: 0px"></div>
        <br />

        <div class="spell-grid-container" id="spellGridContainer" style="width: 0px"></div>
        <div
            id="manualBoostsContainer"
            class="grid-container"
            style="grid-template-columns: auto auto auto auto; width: 0px"
        >
            <div class="grid-item center-vertical" style="border: 0px">
                <input
                    id="manualBoostSlider"
                    type="range"
                    min="200"
                    max="2400"
                    step="200"
                    value="200"
                    oninput="document.getElementById('manualBoostInput').value = this.value; numberOfBoosts=parseInt(this.value)/200;updateExpectedDamage();"
                    style="width: calc(7 * var(--unit))"
                />
            </div>
            <div class="grid-item" style="display: grid; border: 0px; width: calc(8 / 5 * var(--unit))">
                <input
                    id="manualBoostInput"
                    type="text"
                    oninput="document.getElementById('manualBoostSlider').value = this.value; numberOfBoosts=parseInt(this.value)/200;updateExpectedDamage()"
                    onclick="this.value=''"
                    style="
                        width: calc(6 / 5 * var(--unit));
                        height: var(--text-small);
                        font-size: var(--text-small);
                        background-color: #1e1f1b;
                        border-radius: 10px;
                        border: var(--border-width) solid black;
                        text-align: center;
                        justify-self: center;
                        color: #757674;
                    "
                />
            </div>
            <div class="grid-item center-vertical" style="border: 0px; width: var(--icon-width)">
                <input
                    type="image"
                    src="./images/Substract.png"
                    onclick="removeManualBoost()"
                    style="width: var(--icon-width)"
                />
            </div>
            <div class="grid-item center-vertical" style="border: 0px; width: var(--icon-width)">
                <input
                    type="image"
                    src="./images/Add.png"
                    onclick="addManualBoost()"
                    style="width: var(--icon-width)"
                />
            </div>
        </div>
    </body>

    <script>
        // Layout of spells
        const layout = `
            Perturbation Gelure Souvenir Frappe de Xélor Téléportation Engrenage
            Fuite Raulebaque Rembobinage Paradoxe Distortion Désynchronisation
        `
        // Usual/Default Additional Reductions
        const FixedReductionBonuses = [
            {
                iconSRC: './images/Rampart.png',
                alt: 'RAMPART',
                value: 132,
                spellName: 'Rampart',
            },
            {
                iconSRC: './images/Fortification.png',
                alt: 'FORTIF',
                value: 176,
                spellName: 'Fortification',
            },
            {
                iconSRC: "./images/Valkyr's_Embrace.png",
                alt: 'VALKYR',
                value: 99,
                spellName: "Valkyr's Embrace",
            },
            {
                iconSRC: './images/Remission.png',
                alt: 'REMISSION',
                value: 220,
                spellName: 'Remission',
            },
        ]
        const FinalReductionBonuses = [
            {
                iconSRC: './images/Rage.png',
                alt: 'RAGE',
                value: 10,
                spellName: "Ouginak's Rage",
            },
            {
                iconSRC: './images/Rage.png',
                alt: 'RAGE',
                value: 10,
                spellName: "Ouginak's Rage",
            },
            {
                iconSRC: './images/Watchdog.png',
                alt: 'WATCHDOG',
                value: 15,
                spellName: 'Watchdog',
            },
            {
                iconSRC: './images/Feca_Shield.png',
                alt: 'F SHIELD',
                value: 35,
                spellName: 'Feca Shield',
            },
            {
                iconSRC: './images/Ataraxia.png',
                alt: 'ATARAXIA',
                value: 75,
                spellName: 'Ataraxia',
            },
        ]
        // Constants
        /**
         * OLD Spells
        const spellsEN = [
            'Slow Down',
            'Souvenir',
            'Teleportation',
            'Spontaneous Return',
            'Rewind',
            'Reflect',
            "Xelor's Punch",
            'Gear',
            'Frostbite',
            'Disruption',
            "Xelor's Sandglass",
            'Temporal Distortion',
            'Temporal Dust',
            'Temporal Suspension',
            'Rhol Bak',
            'Temporal Instability',
            'Loss of Motivation',
            'Pendulum',
            'Temporal Paradox',
            'Time Rift',
            'Counter',
            'Temporal Oop Shield',
            'Flight',
            'Premonition',
            'Desynchronisation',
            'Knell',
        ]
        const spellsFR = [
            'Ralentissement',
            'Souvenir',
            'Téléportation',
            'Retour Spontané',
            'Rembobinage',
            'Renvoi',
            'Frappe de Xélor',
            'Engrenage',
            'Gelure',
            'Perturbation',
            'Sablier de Xélor',
            'Distortion Temporelle',
            'Poussière Temporelle',
            'Suspension Temporelle',
            'Raulebaque',
            'Instabilité Temporelle',
            'Démotivation',
            'Pendule',
            'Paradoxe Temporel',
            'Faille Temporelle',
            'Contre',
            'Bouclier Temporel',
            'Fuite',
            'Prémonition',
            'Désynchronisation',
            'Glas',
        ]
        */
        const spellsEN = [
            'Spontaneous Return, but bad',
            'Disruption',
            'Dropper',
            'Dust',
            'Gear',
            'Paradox',
            'Pendulum',
            'Premonition',
            'Rewind',
            'Rift',
            'Souvenir',
            'Teleportation',
            'Cog',
            'Desynchronisation',
            'Distortion',
            'Frostbite',
            'Instability',
            'Passage of Time',
            'Permutation',
            'Remanence',
            'Rhol Bak',
            'Sands of Time',
            'Spacetime',
            "Xelor's Punch",
        ]
        const spellsFR = [
            'Astrochiasse',
            'Perturbation',
            'Compte-Goutte',
            'Poussière',
            'Engrenage',
            'Paradoxe',
            'Pendule',
            'Prémonition',
            'Rembobinage',
            'Faille',
            'Souvenir',
            'Téléportation',
            'Rouage',
            'Désynchronisation',
            'Distortion',
            'Gelure',
            'Instabilité',
            'Fuite',
            'Permutation',
            'Rémanence',
            'Raulebaque',
            'Sables du Temps',
            'Espace-Temps',
            'Frappe de Xélor',
        ]

        const otherSpellsEN = [
            '',
            'Rampart',
            'Fortification',
            "Valkyr's Embrace",
            'Remission',
            "Ouginak's Rage",
            'Watchdog',
            'Feca Shield',
            'Ataraxia',
            'Custom Reduction',
            'Add a spell with a custom amount',
            'Manual Mode',
            'Reset',
            'Validate',
            'Cancel',
            'YES',
            'NO',
        ]
        const otherSpellsFR = [
            '',
            'Rempart',
            'Fortification',
            'Étreinte de Valkyr',
            'Rémission',
            'Rage',
            'Molosse',
            'Bouclier Feca',
            'Ataraxie',
            'Réduction Custom',
            'Ajouter une réduction avec une valeur custom',
            'Mode Manuel',
            'Reset',
            'Valider',
            'Annuler',
            'OUI',
            'NON',
        ]

        const availableLocales = ['EN', 'FR']
        const localeFlags = {
            FR: './images/FR-flag.jpeg',
            EN: './images/EN-flag.png',
        }

        const spellsALLXelor = [].concat(spellsFR, spellsEN)
        const variant = {
            Teleportation: 'Spontaneous Return, but bad',
            Disruption: 'Cog',
            Gear: 'Dropper',
            Frostbite: 'Dust',
            Paradox: 'Rift',
            "Xelor's Punch": 'Pendulum',
            'Passage of Time': 'Premonition',
            Rewind: 'Remanence',
            Souvenir: 'Permutation',
            Desynchronisation: 'Spacetime',
            Distortion: 'Sands of Time',
            'Rhol Bak': 'Instability',
            'Spontaneous Return, but bad': 'Teleportation',
            Cog: 'Disruption',
            Dropper: 'Gear',
            Dust: 'Frostbite',
            Rift: 'Paradox',
            Pendulum: "Xelor's Punch",
            Premonition: 'Passage of Time',
            Remanence: 'Rewind',
            Permutation: 'Souvenir',
            Spacetime: 'Desynchronisation',
            'Sands of Time': 'Distortion',
            Instability: 'Rhol Bak',
            /*
            * OLD
            'Slow Down': 'Souvenir',
            Souvenir: 'Slow Down',
            Teleportation: 'Spontaneous Return',
            'Spontaneous Return': 'Teleportation',
            Rewind: 'Reflect',
            Reflect: 'Rewind',
            "Xelor's Punch": 'Gear',
            Gear: "Xelor's Punch",
            Frostbite: 'Disruption',
            Disruption: 'Frostbite',
            "Xelor's Sandglass": 'Temporal Distortion',
            'Temporal Distortion': "Xelor's Sandglass",
            'Temporal Dust': 'Temporal Suspension',
            'Temporal Suspension': 'Temporal Dust',
            'Rhol Bak': 'Temporal Instability',
            'Temporal Instability': 'Rhol Bak',
            'Loss of Motivation': 'Pendulum',
            Pendulum: 'Loss of Motivation',
            'Temporal Paradox': 'Time Rift',
            'Time Rift': 'Temporal Paradox',
            Counter: 'Temporal Oop Shield',
            'Temporal Oop Shield': 'Counter',
            Flight: 'Premonition',
            Premonition: 'Flight',
            Desynchronisation: 'Knell',
            Knell: 'Desynchronisation',
            */
        }
        const telefrag = {
            'Spontaneous Return, but bad': true,
            Disruption: true,
            Dropper: true,
            Dust: true,
            Gear: true,
            Paradox: true,
            Pendulum: true,
            Premonition: true,
            Rewind: true,
            Rift: true,
            Souvenir: true,
            Teleportation: true,
            Cog: true,
            Desynchronisation: true,
            Distortion: true,
            Frostbite: true,
            Instability: true,
            'Passage of Time': true,
            Permutation: true,
            Remanence: true,
            'Rhol Bak': true,
            'Sands of Time': true,
            Spacetime: true,
            "Xelor's Punch": true,
            /*
            * OLD
            'Slow Down': false,
            Souvenir: true,
            Teleportation: true,
            'Spontaneous Return': true,
            Rewind: true,
            Reflect: true,
            "Xelor's Punch": true,
            Gear: true,
            Frostbite: true,
            Disruption: true,
            "Xelor's Sandglass": false,
            'Temporal Distortion': true,
            'Temporal Dust': true,
            'Temporal Suspension': false,
            'Rhol Bak': true,
            'Temporal Instability': true,
            'Loss of Motivation': false,
            Pendulum: true,
            'Temporal Paradox': true,
            'Time Rift': true,
            Counter: false,
            'Temporal Oop Shield': true,
            Flight: true,
            Premonition: true,
            Desynchronisation: true,
            Knell: false,
            */
        }
        const shortName = {
            'Spontaneous Return, but bad': 'SRBB',
            Disruption: 'Disruption',
            Dropper: 'Dropper',
            Dust: 'Dust',
            Gear: 'Gear',
            Paradox: 'Paradox',
            Pendulum: 'Pendulum',
            Premonition: 'Premo',
            Rewind: 'Rewind',
            Rift: 'Rift',
            Souvenir: 'Souvenir',
            Teleportation: 'TP',
            Cog: 'Cog',
            Desynchronisation: 'Desynch',
            Distortion: 'Disto',
            Frostbite: 'Frosbite',
            Instability: 'Instab',
            'Passage of Time': 'PoT',
            Permutation: 'Permutation',
            Remanence: 'Remanence',
            'Rhol Bak': 'RB',
            'Sands of Time': 'Sands',
            Spacetime: 'Spacetime',
            "Xelor's Punch": 'Punch',
            /*
            'Slow Down': 'Slow',
            Souvenir: 'Souv',
            Teleportation: 'TP',
            'Spontaneous Return': 'SR',
            Rewind: 'RW',
            Reflect: 'RF',
            "Xelor's Punch": 'Punch',
            Gear: 'Gear',
            Frostbite: 'FB',
            Disruption: 'Disrupt',
            "Xelor's Sandglass": 'Sandglass',
            'Temporal Distortion': 'Disto',
            'Temporal Dust': 'Dust',
            'Temporal Suspension': 'Susp',
            'Rhol Bak': 'RB',
            'Temporal Instability': 'Instab',
            'Loss of Motivation': 'LOM',
            Pendulum: 'Pendulum',
            'Temporal Paradox': 'Paradox',
            'Time Rift': 'Rift',
            Counter: 'Counter',
            'Temporal Oop Shield': 'Shield',
            Flight: 'Flight',
            Premonition: 'Premo',
            Desynchronisation: 'Desync',
            Knell: 'Knell',
            */
        }
        // Translation-related stuff
        // Spell name translation done using the fixed order of spells lists
        const translateXelorSpells = {}
        for (let i = 0; i < spellsEN.length; ++i) {
            translateXelorSpells[spellsFR[i]] = spellsEN[i]
        }
        const translateOtherSpells = {}
        for (let i = 0; i < otherSpellsEN.length; ++i) {
            translateOtherSpells[otherSpellsFR[i]] = otherSpellsEN[i]
        }
        // Labels are kept here
        const labels = {
            EN: {
                percentAirResLabel: '% Air Res',
                fixedAirResLabel: '&nbsp Air Res',
                meleeResLabel: '% Melee',
                rangeResLabel: '% Range',
                additionalFixedReductionContainerLabel: 'Fixed Reductions',
                additionalFinalReductionContainerLabel: 'Final Reductions',
                levelXelLabel: 'Level',
                baseDamageLabel: 'Base Damage',
                powerBoostLabel: 'Power',
                damageBoostLabel: 'Fixed +Dmg',
            },
            FR: {
                percentAirResLabel: '% Res Air',
                fixedAirResLabel: '&nbsp Res Air',
                meleeResLabel: '% Mélée',
                rangeResLabel: '% Dist. ',
                additionalFixedReductionContainerLabel: 'Réductions Dégâts Fixes',
                additionalFinalReductionContainerLabel: 'Réductions % Finaux',
                levelXelLabel: 'Niveau',
                baseDamageLabel: 'Dégâts de base',
                powerBoostLabel: 'Puissance',
                damageBoostLabel: 'Do Fixes',
            },
        }

        // Globals
        let baseDamage = 368
        let numberOfBoosts = 0
        let expectedDamage = 0

        let finalFactor = 1
        const activeAdditionalFinalResIDS = []
        let meleeFactor = 1
        let rangeFactor = 1
        let fixedAirRes = 0
        let fixedAdditionalRes = 0
        let powerBoost = 0
        let damageBoost = 0
        const activeAdditionalFixedResIDS = []
        let percentAirRes = 0

        let currentLocaleID = 'FR'

        let manualBoostMode = false

        const boost = {
            Teleportation: 0,
            Disruption: 0,
            Gear: 0,
            Frostbite: 0,
            Paradox: 0,
            "Xelor's Punch": 0,
            'Passage of Time': 0,
            Rewind: 0,
            Souvenir: 0,
            Desynchronisation: 0,
            Distortion: 0,
            'Rhol Bak': 0,
            /* OLD
            'Slow Down': 0,
            Teleportation: 0,
            Rewind: 0,
            "Xelor's Punch": 0,
            Frostbite: 0,
            "Xelor's Sandglass": 0,
            'Temporal Dust': 0,
            'Rhol Bak': 0,
            'Loss of Motivation': 0,
            'Temporal Paradox': 0,
            Counter: 0,
            Flight: 0,
            Desynchronisation: 0,
            */
        }

        // Functions and Methods
        // Translation
        function cycleLocale() {
            const i = availableLocales.indexOf(currentLocaleID)
            currentLocaleID = availableLocales[(i + 1) % availableLocales.length]
            refreshLocalisedText()
        }
        function init() {
            // Hide away manual controls
            document.getElementById('manualBoostsContainer').style.setProperty('display', 'none')
            // store baseDamage from input value
            // or reset input to default value of baseDamage
            if (document.getElementById('baseDamage').value) {
                // If the broswer has a cached value for this, use it
                baseDamage = Math.floor(Number(document.getElementById('baseDamage').value))
            } else {
                // reset
                document.getElementById('baseDamage').value = baseDamage
            }
            // fill grids
            const layoutArray = parseLayoutString(layout)
            createSpellGrid(layoutArray)
            fillAdditionalReductionGrids()
            fillLabels()
        }
        function refreshLocalisedText() {
            refreshSpellGridHoverText()
            refreshAdditionalReductionNodes()
            fillLabels()
            const localeCodeNode = document.getElementById('currentLocaleCode')
            localeCodeNode.replaceChildren()
            localeCodeNode.appendChild(document.createTextNode(currentLocaleID))
            const localeImageNode = document.getElementById('currentLocaleImageNode')
            localeImageNode.setAttribute('src', getLocaleImage(currentLocaleID))
        }
        function getLocaleImage(localeID) {
            return localeFlags[localeID]
        }
        function getLabelText(labelID, localeID) {
            return labels[localeID][labelID]
        }
        function fillLabels() {
            for (labelID in labels['EN']) {
                const labelNode = document.getElementById(labelID)
                labelNode.innerHTML = getLabelText(labelID, currentLocaleID)
            }
        }
        function getLocalisedName(baseSpellName, localeID) {
            const spellID = spellsEN.indexOf(baseSpellName)
            if (spellID === -1) {
                const spellIDTry2 = otherSpellsEN.indexOf(baseSpellName)
                if (spellIDTry2 === -1) {
                    throw new Error('Cannot find spell' + baseSpellName)
                    return 'ERROR'
                }
                switch (localeID) {
                    case 'FR':
                        return otherSpellsFR[spellIDTry2]
                    case 'EN':
                        return otherSpellsEN[spellIDTry2]
                    default:
                        throw new Error('Unexpected locale ID')
                        return 'ERROR'
                }
            }
            switch (localeID) {
                case 'FR':
                    return spellsFR[spellID]
                case 'EN':
                    return spellsEN[spellID]
                default:
                    throw new Error('Unexpected locale ID')
                    return 'ERROR'
            }
        }
        // utilitary
        function getBaseName(localisedSpellName) {
            // console.log(`getBaseName('${localisedSpellName}') :\n  localisedSpellName in spellsALLXelor : ${spellsALLXelor.indexOf(localisedSpellName) > -1}\n    localisedSpellName in spellsEN : ${spellsEN.indexOf(localisedSpellName) > -1}\n  localisedSpellName in otherSpellsEN : ${otherSpellsEN.indexOf(localisedSpellName) > -1}`)
            if (spellsALLXelor.indexOf(localisedSpellName) > -1) {
                return spellsEN.indexOf(localisedSpellName) > -1
                    ? localisedSpellName
                    : translateXelorSpells[localisedSpellName]
            } else {
                return otherSpellsEN.indexOf(localisedSpellName) > -1
                    ? localisedSpellName
                    : translateOtherSpells[localisedSpellName]
            }
        }
        function getShortName(spell) {
            return shortName[spell]
        }
        function getVariantOf(spell) {
            return variant[spell]
        }
        function canTelefrag(spell) {
            return telefrag[spell]
        }
        function getImagePath(spell) {
            return `./images/spells/${spell.replace(/ /g, '_')}.png`
        }
        function getIconPath(iconName) {
            return `./images/${iconName.replace(/ /g, '_')}.png`
        }
        function extractSpell(string) {
            for (spellName of spellsALLXelor) {
                // try to find the spell's name
                const matchResult = string.match(`^(?<shit> *)(?<spell>${spellName}) ?(?<remaining>.*)$`)
                if (matchResult) {
                    return matchResult.groups
                }
                //console.log()
            }
            throw new Error('Unable to extract spell from input string')
        }
        function parseLayoutString(layoutString) {
            const lines = []
            for (let line of layoutString.split('\n')) {
                // Parse line into array of spells that exist
                let remainingString = line
                const spellsFound = []
                while (remainingString.length > 0) {
                    try {
                        const resultOfExtraction = extractSpell(remainingString)
                        spellsFound.push(getBaseName(resultOfExtraction.spell))
                        remainingString = resultOfExtraction.remaining
                    } catch (err) {
                        break
                    }
                }
                lines.push(spellsFound)
            }
            if (lines[0].length == 0) {
                lines.shift()
            }
            if (lines[lines.length - 1].length == 0) {
                lines.pop()
            }
            return lines
        }
        // functional
        function toggleSpellBoost(spell) {
            if (!canTelefrag(spell)) {
                return
            }
            const myNode = document.getElementById(`spellGridItem-${getShortName(spell)}`)
            if (typeof boost[spell] !== 'undefined') {
                // spell is a base spell, use value 1 to signal the base spell is activated
                boost[spell] = boost[spell] > 0 ? 0 : 1
            } else {
                // spell is a variant, use value 2 to signal the variant spell is activated
                boost[getVariantOf(spell)] = boost[getVariantOf(spell)] > 0 ? 0 : 2
            }
            updateSpellNodeColor(spell)
            updateExpectedDamage()
        }
        function updateSpellNodeColor(spell) {
            const baseSpell = typeof boost[spell] !== 'undefined' ? spell : getVariantOf(spell)
            const val = boost[baseSpell]
            if (val === 1) {
                activateBoostNode(baseSpell)
            } else if (val === 2) {
                activateBoostNode(getVariantOf(baseSpell))
            } else {
                deactivateBoostNode(baseSpell)
            }
        }
        function activateBoostNode(spell) {
            const myNode = document.getElementById(`spellGridItem-${getShortName(spell)}`)
            myNode.style.setProperty('background-color', '#267E08')
            if (canTelefrag(getVariantOf(spell))) {
                document
                    .getElementById(`spellGridItem-${getShortName(getVariantOf(spell))}`)
                    .style.setProperty('background-color', 'rgba(255,255,255,0.2)')
            }
        }
        function deactivateBoostNode(spell) {
            const myNode = document.getElementById(`spellGridItem-${getShortName(spell)}`)
            // reset background if eligible, also reset for variant if eligible
            if (canTelefrag(spell)) {
                myNode.style.setProperty('background-color', '#757674')
            }
            if (canTelefrag(getVariantOf(spell))) {
                document
                    .getElementById(`spellGridItem-${getShortName(getVariantOf(spell))}`)
                    .style.setProperty('background-color', '#757674')
            }
        }
        function createSpellGrid(layout) {
            const spellGridContainerNode = document.getElementById('spellGridContainer')
            spellGridContainerNode.replaceChildren()
            const columns = layout.reduce(
                (maxCol, line, i) => Math.max(maxCol, line.length + (i === layout.length - 1 ? 1 : 0)),
                0
            )
            const rows = layout.length
            spellGridContainerNode.style.setProperty('grid-template-columns', '1fr '.repeat(columns))
            spellGridContainerNode.style.setProperty('grid-template-rows', '1fr '.repeat(2 * rows))
            for (lineIndex in layout) {
                const line = layout[lineIndex]
                const lineA = []
                const lineB = []
                for (spell of line) {
                    const myImage = document.createElement('input')
                    myImage.setAttribute('id', `spellGridItem-${getShortName(spell)}`)
                    myImage.setAttribute('title', getLocalisedName(spell, currentLocaleID))
                    if (!canTelefrag(spell)) myImage.style.setProperty('background-color', 'rgba(0,0,0,0)')
                    else myImage.style.setProperty('background-color', '#757674')
                    myImage.classList.add('grid-item')
                    myImage.setAttribute('type', 'image')
                    myImage.setAttribute('src', getImagePath(spell))
                    myImage.style.width = 'var(--unit)'
                    myImage.setAttribute('alt', `[ICON : ${getShortName(spell)}]`)
                    myImage.setAttribute('onclick', `toggleSpellBoost("${spell}");`)
                    lineA.push(myImage)

                    const variantSpell = getVariantOf(spell)
                    const myVariantImage = document.createElement('input')
                    myVariantImage.setAttribute('id', `spellGridItem-${getShortName(variantSpell)}`)
                    myVariantImage.setAttribute('title', getLocalisedName(variantSpell, currentLocaleID))
                    if (!canTelefrag(variantSpell))
                        myVariantImage.style.setProperty('background-color', 'rgba(0,0,0,0)')
                    else myVariantImage.style.setProperty('background-color', '#757674')
                    myVariantImage.classList.add('grid-item')
                    myVariantImage.setAttribute('type', 'image')
                    myVariantImage.setAttribute('src', getImagePath(variantSpell))
                    myVariantImage.style.width = 'var(--unit)'
                    myVariantImage.setAttribute('alt', `[ICON : ${getShortName(variantSpell)}]`)
                    myVariantImage.setAttribute('onclick', `toggleSpellBoost("${variantSpell}");`)
                    lineB.push(myVariantImage)
                }
                for (node of lineA) {
                    spellGridContainerNode.appendChild(node)
                }

                for (let i = lineA.length; i < columns - (lineIndex == rows - 1 ? 1 : 0); ++i) {
                    const node = document.createElement('div')
                    node.classList.add('grid-item')
                    node.setAttribute('title', '')
                    node.style.setProperty('padding', '0px')
                    node.style.setProperty('border', '0px')
                    spellGridContainerNode.appendChild(node)
                }
                // If it's the last line, add the reset "spell" on the last column (first row)
                if (lineIndex == rows - 1) {
                    const myImage = document.createElement('input')
                    myImage.setAttribute('id', `spellGridItem-MenuTop`)
                    myImage.setAttribute('title', 'Manual Mode')
                    myImage.style.setProperty('background-color', '#757674')
                    myImage.classList.add('grid-item')
                    myImage.setAttribute('type', 'image')
                    myImage.setAttribute('src', getIconPath('Pause'))
                    myImage.style.width = 'var(--unit)'
                    myImage.setAttribute('alt', '[MANUAL MODE]')
                    myImage.setAttribute('onclick', 'manualBoostOverride();')
                    spellGridContainerNode.appendChild(myImage)
                }

                for (node of lineB) {
                    spellGridContainerNode.appendChild(node)
                }
                for (let i = lineB.length; i < columns - (lineIndex == rows - 1 ? 1 : 0); ++i) {
                    const node = document.createElement('div')
                    node.classList.add('grid-item')
                    node.style.setProperty('padding', '0px')
                    node.style.setProperty('border', '0px')
                    spellGridContainerNode.appendChild(node)
                }
                // If it's the last line, add the reset "spell" on the last column (second row)
                if (lineIndex == rows - 1) {
                    const myImage = document.createElement('input')
                    myImage.setAttribute('id', `spellGridItem-MenuBot`)
                    myImage.setAttribute('title', getLocalisedName('Reset', currentLocaleID))
                    myImage.style.setProperty('background-color', '#757674')
                    myImage.classList.add('grid-item')
                    myImage.setAttribute('type', 'image')
                    myImage.setAttribute('src', getIconPath('Reset'))
                    myImage.style.width = 'var(--unit)'
                    myImage.setAttribute('alt', `[ICON : RESET]`)
                    myImage.setAttribute('onclick', `confirmBoostReset();`)
                    spellGridContainerNode.appendChild(myImage)
                }
            }
        }
        function manualBoostOverride() {
            manualBoostMode = true
            // Show manual boost controls
            document.getElementById('manualBoostsContainer').style.setProperty('display', 'grid')
            // Grey out Normal boost Controls and remove their onclick
            lockBoostNodes()
            // Change Menu Option
            const topOptionNode = document.getElementById('spellGridItem-MenuTop')
            topOptionNode.setAttribute('src', getIconPath('Play'))
            topOptionNode.setAttribute('title', '') // FIXME : Play
            topOptionNode.setAttribute('alt', '') // FIXME : Play
            topOptionNode.setAttribute('onclick', 'endManualBoostOverride();')

            updateExpectedDamage()
        }
        function lockBoostNodes() {
            for (spell in boost) {
                document
                    .getElementById(`spellGridItem-${getShortName(getVariantOf(spell))}`)
                    .style.setProperty('background-color', 'rgba(0,0,0,0)')
                document
                    .getElementById(`spellGridItem-${getShortName(getVariantOf(spell))}`)
                    .setAttribute('onclick', '')
                document
                    .getElementById(`spellGridItem-${getShortName(spell)}`)
                    .style.setProperty('background-color', 'rgba(0,0,0,0)')
                document.getElementById(`spellGridItem-${getShortName(spell)}`).setAttribute('onclick', '')
            }
        }
        function unlockBoostNodes() {
            for (spell in boost) {
                document
                    .getElementById(`spellGridItem-${getShortName(getVariantOf(spell))}`)
                    .style.setProperty('background-color', 'rgba(0,0,0,0)')
                document
                    .getElementById(`spellGridItem-${getShortName(getVariantOf(spell))}`)
                    .setAttribute('onclick', `toggleSpellBoost("${getVariantOf(spell)}");`)
                updateSpellNodeColor(getVariantOf(spell))
                document
                    .getElementById(`spellGridItem-${getShortName(spell)}`)
                    .style.setProperty('background-color', 'rgba(0,0,0,0)')
                document
                    .getElementById(`spellGridItem-${getShortName(spell)}`)
                    .setAttribute('onclick', `toggleSpellBoost("${spell}");`)
                updateSpellNodeColor(spell)
            }
        }
        function addManualBoost() {
            const sliderObj = document.getElementById('manualBoostSlider')
            const textInputNode = document.getElementById('manualBoostInput')
            sliderObj.stepUp()
            textInputNode.value = sliderObj.value
            updateExpectedDamage()
        }
        function removeManualBoost() {
            const sliderObj = document.getElementById('manualBoostSlider')
            const textInputNode = document.getElementById('manualBoostInput')
            sliderObj.stepDown()
            textInputNode.value = sliderObj.value
            updateExpectedDamage()
        }
        function endManualBoostOverride() {
            manualBoostMode = false
            // Hide away manual boost controls
            document.getElementById('manualBoostsContainer').style.setProperty('display', 'none')
            // unlock Normal boost Controls
            unlockBoostNodes()
            // Change Menu Option
            const topOptionNode = document.getElementById('spellGridItem-MenuTop')
            topOptionNode.setAttribute('src', getIconPath('Pause'))
            topOptionNode.setAttribute('title', '') // FIXME : Pause
            topOptionNode.setAttribute('alt', '') // FIXME : Pause
            topOptionNode.setAttribute('onclick', 'manualBoostOverride();')
            // Update damage
            updateExpectedDamage()
        }
        function showBoostsUpForReset() {
            // Change all spells color to indicate what's at play
            for (spell in boost) {
                if (boost[spell]) {
                    if (canTelefrag(getVariantOf(spell)))
                        document
                            .getElementById(`spellGridItem-${getShortName(getVariantOf(spell))}`)
                            .style.setProperty('background-color', '#ffce00')
                    if (canTelefrag(spell))
                        document
                            .getElementById(`spellGridItem-${getShortName(spell)}`)
                            .style.setProperty('background-color', '#ffce00')
                }
            }
        }
        // The opposite of above
        function spellsBackToNormal() {
            if (manualBoostMode) {
                lockBoostNodes()
                return
            }
            for (spell in boost) {
                if (boost[spell]) {
                    if (canTelefrag(getVariantOf(spell))) updateSpellNodeColor(getVariantOf(spell))
                    if (canTelefrag(spell)) updateSpellNodeColor(spell)
                }
            }
        }
        function confirmBoostReset() {
            showBoostsUpForReset()
            // Change Menu options
            const topOptionNode = document.getElementById('spellGridItem-MenuTop')
            const botOptionNode = document.getElementById('spellGridItem-MenuBot')
            // Change Images, titles & alt
            topOptionNode.setAttribute('src', getIconPath('Validate'))
            botOptionNode.setAttribute('src', getIconPath('Cancel'))

            topOptionNode.setAttribute('alt', getLocalisedName('YES', currentLocaleID))
            botOptionNode.setAttribute('alt', getLocalisedName('NO', currentLocaleID))

            topOptionNode.setAttribute('title', getLocalisedName('Validate', currentLocaleID))
            botOptionNode.setAttribute('title', getLocalisedName('Cancel', currentLocaleID))

            // change onclick code
            topOptionNode.setAttribute('onclick', 'resetBoosts();resetBoostMenuOptions();')
            botOptionNode.setAttribute('onclick', 'spellsBackToNormal();resetBoostMenuOptions();')
        }
        function resetBoostMenuOptions() {
            const topOptionNode = document.getElementById('spellGridItem-MenuTop')
            const botOptionNode = document.getElementById('spellGridItem-MenuBot')
            // Change Images
            topOptionNode.setAttribute('src', manualBoostMode ? getIconPath('Play') : getIconPath('Pause'))
            botOptionNode.setAttribute('src', getIconPath('Reset'))

            topOptionNode.setAttribute('alt', '') // FIXME : Pause/Play
            botOptionNode.setAttribute('alt', '[ICON : RESET]')

            topOptionNode.setAttribute('title', '') // FIXME : Pause/Play
            botOptionNode.setAttribute('title', getLocalisedName('Reset', currentLocaleID))
            // change onclick code
            topOptionNode.setAttribute(
                'onclick',
                manualBoostMode ? 'endManualBoostOverride()' : 'manualBoostOverride();'
            )
            botOptionNode.setAttribute('onclick', 'confirmBoostReset();')
        }
        function refreshSpellGridHoverText() {
            const spellContainer = document.getElementById('spellGridContainer')
            for (node of spellContainer.childNodes) {
                node.title = getLocalisedName(getBaseName(node.title), currentLocaleID)
            }
        }
        function resetBoosts() {
            for (spell in boost) {
                boost[spell] = 0
                if (manualBoostMode) {
                    document
                        .getElementById(`spellGridItem-${getShortName(getVariantOf(spell))}`)
                        .style.setProperty('background-color', 'rgba(0,0,0,0)')
                    document
                        .getElementById(`spellGridItem-${getShortName(spell)}`)
                        .style.setProperty('background-color', 'rgba(0,0,0,0)')
                } else updateSpellNodeColor(spell)
            }
            if (!manualBoostMode) updateExpectedDamage()
        }
        // Base Damage
        function updateBaseDamage() {
            baseDamage = Math.floor(Number(document.getElementById('baseDamage').value))
            // reset xelor level displayed
            document.getElementById('levelXel').value = 'N/A'
            updateExpectedDamage()
        }
        function updateXelorLevel() {
            // Use 42Scientist's conclusions :
            /**
             * Spell is 23 damage
             * Synchro has 0 damage stat
             * Synchro has 666 base power
             *  + 100 at rank 2 (level 157)
             *  + scale linearly ?
             *    -> on each portion ?
             */
            const baseLevel = 90
            const at90 = 760
            // The 157 - 200 range seems pretty good so keep this as a reference
            const at157 = 1285 // in the 1276 - 1294 range
            const at156 = 1024 // at157 - 261

            // Note :
            /**
             * It seems some of our data for level 90/some lv1XX points
             *  was from before the changes to the rank 1 Synchro
             *
             *
             * 90 : 197 (not confirmed)
             * 96 : 203
             * 106 : 212
             * 112 : 218
             * 120 : 225
             *
             *
             * 145 : 248
             * 146 : 249
             * 147 : 250
             * 148 : 251
             *
             * 164 : 326
             *
             *
             * 191 : 357
             * 197 : 364
             * 199 : 366
             */

            // Bind level to a number between 90 and 200, also an int
            // lv200 if cannot parse
            const xelorLvl = Math.min(
                Math.max(Math.floor(Number(document.getElementById('levelXel').value) || 200), 90),
                200
            )
            // Calculate power stat
            // Assume linear on two zones
            if (xelorLvl >= 157) {
                // This means a 5 power/level increase
                const power = Math.floor(((xelorLvl - 157) / (200 - 157)) * (1500 - at157) + at157)
                baseDamage = Math.floor((1 + power / 100) * 23)
            } else {
                // This means a 4 power/level increase
                const power = Math.floor(((xelorLvl - 90) / (156 - 90)) * (at156 - at90) + at90)
                baseDamage = Math.floor((1 + power / 100) * 23)
            }

            document.getElementById('baseDamage').value = baseDamage.toFixed(0)
            updateExpectedDamage()
        }
        function updatePowerBoost() {
            powerBoost = Math.floor(Number(document.getElementById('powerBoost').value))
            updateExpectedDamage()
        }
        function updateDamageBoost() {
            damageBoost = Math.floor(Number(document.getElementById('damageBoost').value))
            updateExpectedDamage()
        }

        // Reductions
        function refreshAdditionalReductionNodes() {
            const fixedContainer = document.getElementById('additionalFixedReductionContainer')
            const finalContainer = document.getElementById('additionalFinalReductionContainer')
            for (node of fixedContainer.childNodes) {
                refreshAdditionalFixedReductionNode(node)
            }
            for (node of finalContainer.childNodes) {
                refreshAdditionalFinalReductionNode(node)
            }
        }
        // Fixed Reductions
        function refreshAdditionalFixedReductionNode(nodeObject) {
            nodeObject.firstChild.title = getLocalisedName(getBaseName(nodeObject.firstChild.title), currentLocaleID)
            if (activeAdditionalFixedResIDS.includes(nodeObject.id)) {
                // Activate
                nodeObject.style.setProperty('background-color', '#267E08')
            } else {
                // Deactivate
                nodeObject.style.setProperty('background-color', '#757674')
            }
        }
        function toggleAdditionalFixedReduction(nodeID) {
            const myNode = document.getElementById(nodeID)
            if (activeAdditionalFixedResIDS.includes(nodeID)) {
                // Deactivate
                myNode.style.setProperty('background-color', '#757674')
                activeAdditionalFixedResIDS.splice(activeAdditionalFixedResIDS.indexOf(nodeID), 1)
                // Fuck you JS, can't even remove an element properly
            } else {
                // Activate
                myNode.style.setProperty('background-color', '#267E08')
                activeAdditionalFixedResIDS.push(nodeID)
            }
            updateExpectedDamage()
        }
        function addNewAdditionalFixedReduction() {
            const containerNode = document.getElementById('additionalFixedReductionContainer')
            const width = containerNode.childNodes.length
            const newValue = document.getElementById('additionalFixedReductionItem-CustomInput').value

            // Only work if the new Value is valid (= Number and ParseInt agree on value)
            if (newValue !== '' && Number(newValue) == parseInt(newValue)) {
                // make room for 1 more element on the grid
                containerNode.style.setProperty('grid-template-columns', '1fr '.repeat(width + 1))

                const newNode = document.createElement('div')
                newNode.classList.add('grid-item')
                newNode.setAttribute('id', `additionalFixedReductionItem-${width}`)
                newNode.style.setProperty('background-color', '#757674')

                const newImg = document.createElement('input')
                newImg.setAttribute('type', 'image')
                newImg.setAttribute('src', './images/unknown_shield.png') // Dev Note : Find better icon
                newImg.style.width = 'var(--unit)'
                newImg.setAttribute('alt', '[CUSTOM]')
                newImg.setAttribute('title', getLocalisedName('Custom Reduction', currentLocaleID))
                newImg.setAttribute(
                    'onclick',
                    `toggleAdditionalFixedReduction("additionalFixedReductionItem-${width}")`
                )
                newNode.appendChild(newImg)

                const newText = document.createElement('p')
                newText.style.setProperty('color', '#EAEBE7')
                newText.style.fontSize = 'var(--text-small)'
                newText.style.setProperty('text-align', 'center')

                const newInput = document.createTextNode(newValue)
                newText.appendChild(newInput)

                newNode.appendChild(newText)

                containerNode.insertBefore(newNode, containerNode.childNodes[width - 1])
            } else {
                console.log('invalid custom fixed reduction, not adding')
            }
        }
        function fillAdditionalFixedReductionGrid() {
            const containerNode = document.getElementById('additionalFixedReductionContainer')
            containerNode.replaceChildren()
            containerNode.style.setProperty('grid-template-columns', '1fr '.repeat(FixedReductionBonuses.length + 1))
            for (i in FixedReductionBonuses) {
                const newNode = document.createElement('div')
                const newNodeID = `additionalFixedReductionItem-${i}`
                newNode.classList.add('grid-item')
                newNode.setAttribute('id', newNodeID)
                newNode.style.setProperty('background-color', '#757674')

                const newImg = document.createElement('input')
                newImg.setAttribute('type', 'image')
                newImg.setAttribute('src', FixedReductionBonuses[i].iconSRC)
                newImg.setAttribute('alt', FixedReductionBonuses[i].alt)
                newImg.setAttribute('title', getLocalisedName(FixedReductionBonuses[i].spellName, currentLocaleID))
                newImg.setAttribute('onclick', `toggleAdditionalFixedReduction("additionalFixedReductionItem-${i}")`)
                newImg.style.width = 'var(--unit)'
                newNode.appendChild(newImg)

                const newText = document.createElement('p')
                newText.style.setProperty('color', '#EAEBE7')
                newText.style.fontSize = 'var(--text-small)'
                newText.style.setProperty('text-align', 'center')
                const t = document.createTextNode(FixedReductionBonuses[i].value)
                newText.appendChild(t)

                newNode.appendChild(newText)

                containerNode.appendChild(newNode)
                // refreshAdditionalFixedReductionNode(newNode)
            }
            const newNode = document.createElement('div')
            newNode.classList.add('grid-item')
            newNode.classList.add('add-new')
            newNode.setAttribute('id', 'additionalFixedReductionItem-Custom')
            newNode.style.setProperty('background-color', '#757674')

            const newImg = document.createElement('input')
            newImg.setAttribute('type', 'image')
            newImg.setAttribute('src', './images/New.png')
            newImg.style.width = 'var(--unit)'
            newImg.setAttribute('alt', '[ADD]')
            newImg.setAttribute('title', getLocalisedName('Add a spell with a custom amount', currentLocaleID))
            newImg.setAttribute('onclick', 'addNewAdditionalFixedReduction()')
            newNode.appendChild(newImg)

            const newInput = document.createElement('input')
            newInput.setAttribute('id', 'additionalFixedReductionItem-CustomInput')
            newInput.setAttribute('type', 'text')
            newInput.style.width = 'var(--icon-width)'

            newNode.appendChild(newInput)

            containerNode.appendChild(newNode)
        }
        // % Final Reductions
        // Same as fixed (next 4 functions are duplicates of previous 4)
        function refreshAdditionalFinalReductionNode(nodeObject) {
            nodeObject.firstChild.title = getLocalisedName(getBaseName(nodeObject.firstChild.title), currentLocaleID)
            if (activeAdditionalFinalResIDS.includes(nodeObject.id)) {
                // Activate
                nodeObject.style.setProperty('background-color', '#267E08')
            } else {
                // Deactivate
                nodeObject.style.setProperty('background-color', '#757674')
            }
        }
        function toggleAdditionalFinalReduction(nodeID) {
            const myNode = document.getElementById(nodeID)
            if (activeAdditionalFinalResIDS.includes(nodeID)) {
                // Deactivate
                myNode.style.setProperty('background-color', '#757674')
                activeAdditionalFinalResIDS.splice(activeAdditionalFinalResIDS.indexOf(nodeID), 1)
                // Fuck you JS, can't even remove an element properly
            } else {
                // Activate
                myNode.style.setProperty('background-color', '#267E08')
                activeAdditionalFinalResIDS.push(nodeID)
            }
            updateExpectedDamage()
        }
        function addNewAdditionalFinalReduction() {
            const containerNode = document.getElementById('additionalFinalReductionContainer')
            const width = containerNode.childNodes.length
            const newValue = document.getElementById('additionalFinalReductionItem-CustomInput').value

            // Only work if the new Value is valid (= Number and ParseInt agree on value)
            if (newValue !== '' && Number(newValue) == parseInt(newValue)) {
                containerNode.style.setProperty('grid-template-columns', '1fr '.repeat(width + 1))

                const newNode = document.createElement('div')
                newNode.classList.add('grid-item')
                newNode.setAttribute('id', `additionalFinalReductionItem-${width}`)
                newNode.style.setProperty('background-color', '#757674')

                const newImg = document.createElement('input')
                newImg.setAttribute('type', 'image')
                newImg.setAttribute('src', './images/unknown_shield.png') // Dev Note : Find better icon
                newImg.style.width = 'var(--unit)'
                newImg.setAttribute('alt', '[CUSTOM]')
                newImg.setAttribute('title', getLocalisedName('Custom Reduction', currentLocaleID))
                newImg.setAttribute(
                    'onclick',
                    `toggleAdditionalFinalReduction("additionalFinalReductionItem-${width}")`
                )
                newNode.appendChild(newImg)

                const newText = document.createElement('p')
                newText.style.setProperty('color', '#EAEBE7')
                newText.style.fontSize = 'var(--text-small)'
                newText.style.setProperty('text-align', 'center')

                const newInput = document.createTextNode(newValue)
                newText.appendChild(newInput)

                newNode.appendChild(newText)

                containerNode.insertBefore(newNode, containerNode.childNodes[width - 1])
            } else {
                console.log('invalid custom final reduction, not adding')
            }
        }
        function fillAdditionalFinalReductionGrid() {
            const containerNode = document.getElementById('additionalFinalReductionContainer')
            containerNode.replaceChildren()
            containerNode.style.setProperty('grid-template-columns', '1fr '.repeat(FinalReductionBonuses.length + 1))
            for (i in FinalReductionBonuses) {
                const newNode = document.createElement('div')
                const newNodeID = `additionalFinalReductionItem-${i}`
                newNode.classList.add('grid-item')
                newNode.setAttribute('id', newNodeID)
                newNode.style.setProperty('background-color', '#757674')

                const newImg = document.createElement('input')
                newImg.setAttribute('type', 'image')
                newImg.setAttribute('src', FinalReductionBonuses[i].iconSRC)
                newImg.setAttribute('alt', FinalReductionBonuses[i].alt)
                newImg.setAttribute('title', getLocalisedName(FinalReductionBonuses[i].spellName, currentLocaleID))
                newImg.setAttribute('onclick', `toggleAdditionalFinalReduction("additionalFinalReductionItem-${i}")`)
                newImg.style.width = 'var(--unit)'
                newNode.appendChild(newImg)

                const newText = document.createElement('p')
                newText.style.setProperty('color', '#EAEBE7')
                newText.style.fontSize = 'var(--text-small)'
                newText.style.setProperty('text-align', 'center')
                const t = document.createTextNode(FinalReductionBonuses[i].value)
                newText.appendChild(t)

                newNode.appendChild(newText)

                containerNode.appendChild(newNode)
                // refreshAdditionalFinalReductionNode(newNode)
            }
            const newNode = document.createElement('div')
            newNode.classList.add('grid-item')
            newNode.classList.add('add-new')
            newNode.setAttribute('id', 'additionalFinalReductionItem-Custom')
            newNode.style.setProperty('background-color', '#757674')

            const newImg = document.createElement('input')
            newImg.setAttribute('type', 'image')
            newImg.setAttribute('src', './images/New.png')
            newImg.style.width = 'var(--unit)'
            newImg.setAttribute('alt', '[ADD]')
            newImg.setAttribute('title', getLocalisedName('Add a spell with a custom amount', currentLocaleID))
            newImg.setAttribute('onclick', 'addNewAdditionalFinalReduction()')
            newNode.appendChild(newImg)

            const newInput = document.createElement('input')
            newInput.setAttribute('id', 'additionalFinalReductionItem-CustomInput')
            newInput.setAttribute('type', 'text')
            newInput.style.width = 'var(--icon-width)'

            newNode.appendChild(newInput)

            containerNode.appendChild(newNode)
        }
        function fillAdditionalReductionGrids() {
            fillAdditionalFixedReductionGrid()
            fillAdditionalFinalReductionGrid()
        }
        function validDamage(floatDamage) {
            return Math.max(Math.floor(floatDamage), 0)
        }
        function recalculateAdditionalFixedRes() {
            let r = 0
            for (nodeID of activeAdditionalFixedResIDS) {
                r += Number(document.getElementById(nodeID).childNodes[1].childNodes[0].textContent)
            }
            fixedAdditionalRes = r
        }
        function recalculateFinalFactor() {
            let factor = 1
            for (nodeID of activeAdditionalFinalResIDS) {
                // take the value, multiply
                factor *= 1 - Number(document.getElementById(nodeID).childNodes[1].childNodes[0].textContent) / 100
            }
            finalFactor = factor
        }
        function recalculateExpectedDamages() {
            // Base damage is 368 max rank
            // rank 1 varies with level ?
            // Dégâts=(368-RéFix)x(1-Ré%Air/100)x(1-Ré%Final/100)x(2xNombreBoosts-1)
            refreshAllValues()
            refreshBoosts()
            recalculateFinalFactor()
            recalculateAdditionalFixedRes()
            const intermediate =
                validDamage(
                    (baseDamage + 23 * (powerBoost / 100) + damageBoost - (fixedAirRes + fixedAdditionalRes)) *
                        (1 - percentAirRes / 100)
                ) *
                finalFactor *
                (2 * numberOfBoosts - 1)
            expectedDamage_melee = validDamage(intermediate * meleeFactor)
            expectedDamage_range = validDamage(intermediate * rangeFactor)
        }
        function updateExpectedDamageDisplays() {
            const myNodeM = document.getElementById('expectedDamageNode-Melee')
            myNodeM.textContent = String(expectedDamage_melee)
            const myNodeR = document.getElementById('expectedDamageNode-Range')
            myNodeR.textContent = String(expectedDamage_range)
        }
        function updateExpectedDamage() {
            recalculateExpectedDamages()
            updateExpectedDamageDisplays()
        }
        function refreshBoosts() {
            if (!manualBoostMode) {
                s = 0
                for (spell in boost) {
                    s += boost[spell] ? 1 : 0
                }
                numberOfBoosts = s
            } else {
                numberOfBoosts = parseInt(document.getElementById('manualBoostSlider').value) / 200
            }
        }
        function refreshMeleeRes() {
            const myNode = document.getElementById('meleeRes')
            meleeFactor = 1 - Number(myNode.value) / 100
        }
        function refreshRangeRes() {
            const myNode = document.getElementById('rangeRes')
            rangeFactor = 1 - Number(myNode.value) / 100
        }
        function refreshFixedAirRes() {
            const myNode = document.getElementById('fixedAirRes')
            fixedAirRes = Number(myNode.value)
        }
        function refreshPercentAirRes() {
            const myNode = document.getElementById('percentAirRes')
            percentAirRes = Number(myNode.value)
        }

        function refreshAllValues() {
            refreshMeleeRes()
            refreshRangeRes()
            refreshFixedAirRes()
            refreshPercentAirRes()
        }
    </script>

    <script>
        // Loading and Init
        init()
    </script>
</html>
