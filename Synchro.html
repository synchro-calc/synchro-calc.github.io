<!DOCTYPE html>
<html>
<head>
    <title>Synchro Calculator</title>
    <style>
    .spell-grid-container {
        width : 60%;
        display: grid;
        background-color: #1E1F1B;
        padding: 1px;
    }
    .grid-container {
        display: grid;
        background-color: #1E1F1B;
        padding: 1px;
    }
    .grid-item {
        border: 1px solid rgba(0, 0, 0, 0.8);
        padding: 4px;
        font-size: 30px;
        text-align: center;
    }
    </style>
</head>

<body style="background-color: #1E1F1B; font-family: 'Courier New', Courier, monospace; color: #EAEBE7;">
    <div style="display: grid;grid-template-columns: 1fr 1fr;">
        <div style="display: grid; justify-items : center;">
            <div class="grid-container" id ="damageGridContainer" style ="grid-template-columns: 1fr 1fr; grid-template-rows: 1fr; width : 80%">
                <div class="grid-item" id="expectedDamageParentNode-Melee" style="background-color : #757674;">
                    <img src="./images/melee.png" alt ='[MELEE ICON]' style="float:left;padding-left: 20%;">
                    <div id="expectedDamageNode-Melee" style="color:black">0</div>
                </div>
                <div class="grid-item" id="expectedDamageParentNode-Range" style="background-color : #757674;">
                    <img src="./images/range.png" alt ='[RANGE ICON]' style="float:left;padding-left: 20%;">
                    <div id="expectedDamageNode-Range" style="color:black">0</div>
                </div>
            </div>
        </div>
        
        <div style="display: grid;justify-items: right;">
            <div id="localeContainer" class="grid-container" style="grid-template-columns: auto auto;margin-bottom: 20px;">
                <div id="currentLocaleCode" class="grid-item" style="border:0px; font-size: medium; margin-bottom: 0px;">FR</div>
                <div class="grid-item" style="border:0px; height:18px" >
                    <input id="currentLocaleImageNode" type="image" src="./images/FR-flag.jpeg" alt='[FLAG]' style="float:right;margin : left 10px top 0px" width="32" onclick="cycleLocale()">
                </div>
            </div>
        </div>
    </div>
    <div style="display : grid; justify-items : center; width : 50%">
        <div>
            <label for="percentAirRes" id="percentAirResLabel">% Air Res</label>
            <input type="text" id="percentAirRes" oninput="updateExpectedDamage()" style="width : 40px;">
            <label for="fixedAirRes" id="fixedAirResLabel">&nbsp&nbsp Air Res</label>
            <input type="text" id="fixedAirRes" oninput="updateExpectedDamage()" style="width : 40px;">
            <br>

            <label for="meleeRes" id="meleeResLabel">% Melee &nbsp</label>
            <input type="text" id="meleeRes" oninput="updateExpectedDamage()" style="width : 40px;">
            <label for="rangeRes" id="rangeResLabel">&nbsp&nbsp % Range</label>
            <input type="text" id="rangeRes" oninput="updateExpectedDamage()" style="width : 40px;"><br>
        </div>
    </div>

    <label for="additionalFixedReductionContainer" id="additionalFixedReductionContainerLabel">Fixed Reductions</label>
    <div class="grid-container" id="additionalFixedReductionContainer" style="width: 0px;"></div>
    <label for="additionalFinalReductionContainer" id="additionalFinalReductionContainerLabel">Final Reductions</label>
    <div class="grid-container" id="additionalFinalReductionContainer" style="width: 0px;"></div>
    <br>

    <div class="spell-grid-container" id ="spellGridContainer" style = "width : 0px; "></div>

</body>

<script>
    // Layout of spells
    const layout = `
        Ralentissement Téléportation Rembobinage Frappe de Xélor Gelure Sablier de Xélor Poussière Temporelle Raulebaque Démotivation Paradoxe Temporel Contre Fuite Désynchronisation
    `
    // Usual/Default Additional Reductions
    const FixedReductionBonuses = [{
        iconSRC : "./images/Rampart.png",
        alt : "RAMPART",
        value : 154,
        spellName : "Rampart (Caster)"
        },{
        iconSRC : "./images/Rampart.png",
        alt : "RAMPART",
        value : 110,
        spellName : "Rampart (Ally)"
        },{
        iconSRC : "./images/Fortification.png",
        alt : "FORTIF",
        value : 220,
        spellName : "Fortification"
        },{
        iconSRC : "./images/Valkyr's_Embrace.png",
        alt : "VALKYR",
        value : 132,
        spellName : "Valkyr's Embrace"
        },
    ]
    const FinalReductionBonuses = [{
        iconSRC : "./images/Rage.png",
        alt : "RAGE",
        value : 10,
        spellName : "Ouginak's Rage"
        },{
        iconSRC : "./images/Rage.png",
        alt : "RAGE",
        value : 10,
        spellName : "Ouginak's Rage"
        },{
        iconSRC : "./images/Watchdog.png",
        alt : "WATCHDOG",
        value : 15,
        spellName : "Watchdog"
        },{
        iconSRC : "./images/Feca_Shield.png",
        alt : "F SHIELD",
        value : 35,
        spellName : "Feca Shield"
        },{
        iconSRC : "./images/Ataraxia.png",
        alt : "ATARAXIA",
        value : 75,
        spellName : "Ataraxia"
        },
    ]
    // Constants
    const spellsEN = ["Slow Down", "Souvenir", "Teleportation", "Spontaneous Return", "Rewind", "Reflect", "Xelor's Punch", "Gear", "Frostbite", "Disruption", "Xelor's Sandglass", "Temporal Distortion", "Temporal Dust", "Temporal Suspension", "Rhol Bak", "Temporal Instability", "Loss of Motivation", "Pendulum", "Temporal Paradox", "Time Rift", "Counter", "Temporal Oop Shield", "Flight", "Premonition", "Desynchronisation", "Knell"]
    const spellsFR = ["Ralentissement", "Souvenir", "Téléportation", "Retour Spontané", "Rembobinage", "Renvoi", "Frappe de Xélor", "Engrenage", "Gelure", "Perturbation", "Sablier de Xélor", "Distortion Temporelle", "Poussière Temporelle", "Suspension Temporelle", "Raulebaque", "Instabilité Temporelle", "Démotivation", "Pendule", "Paradoxe Temporel", "Faille Temporelle", "Contre", "Bouclier Temporel", "Fuite", "Prémonition", "Désynchronisation", "Glas"]

    const otherSpellsEN = ["Rampart (Caster)", "Rampart (Ally)", "Fortification", "Valkyr's Embrace", "Ouginak's Rage", "Watchdog", "Feca Shield", "Ataraxia", "Custom Reduction", "Add a spell with a custom amount"]
    const otherSpellsFR = ["Rempart (Lanceur)", "Rempart (Allié)", "Fortification", "Étreinte de Valkyr", "Rage", "Molosse", "Bouclier Feca", "Ataraxie", "Réduction Custom", "Ajouter une réduction avec une valeur custom"]
    
    const availableLocales = ["EN", "FR"]
    const localeFlags = {
            "FR" : "./images/FR-flag.jpeg",
            "EN" : "./images/EN-flag.png"
        }

    const spellsALLXelor = [].concat(spellsEN, spellsFR)
    const variant = {
        'Slow Down': 'Souvenir',
        'Souvenir': 'Slow Down',
        'Teleportation': 'Spontaneous Return',
        'Spontaneous Return': 'Teleportation',
        'Rewind': 'Reflect',
        'Reflect': 'Rewind',
        "Xelor's Punch": 'Gear',
        'Gear': "Xelor's Punch",
        'Frostbite': 'Disruption',
        'Disruption': 'Frostbite',
        "Xelor's Sandglass": 'Temporal Distortion',
        'Temporal Distortion': "Xelor's Sandglass",
        'Temporal Dust': 'Temporal Suspension',
        'Temporal Suspension': 'Temporal Dust',
        'Rhol Bak': 'Temporal Instability',
        'Temporal Instability': 'Rhol Bak',
        'Loss of Motivation': 'Pendulum',
        'Pendulum': 'Loss of Motivation',
        'Temporal Paradox': 'Time Rift',
        'Time Rift': 'Temporal Paradox',
        'Counter': 'Temporal Oop Shield',
        'Temporal Oop Shield': 'Counter',
        'Flight': 'Premonition',
        'Premonition': 'Flight',
        'Desynchronisation': 'Knell',
        'Knell': 'Desynchronisation'
    }
    const telefrag = {
        'Slow Down': false,
        'Souvenir': true,
        'Teleportation': true,
        'Spontaneous Return': true,
        'Rewind': true,
        'Reflect': true,
        "Xelor's Punch": true,
        'Gear': true,
        'Frostbite': true,
        'Disruption': true,
        "Xelor's Sandglass": false,
        'Temporal Distortion': true,
        'Temporal Dust': true,
        'Temporal Suspension': false,
        'Rhol Bak': true,
        'Temporal Instability': true,
        'Loss of Motivation': false,
        'Pendulum': true,
        'Temporal Paradox': true,
        'Time Rift': true,
        'Counter': false,
        'Temporal Oop Shield': true,
        'Flight': true,
        'Premonition': true,
        'Desynchronisation': true,
        'Knell': false
    }
    const shortName = {
    'Slow Down': 'Slow',
    'Souvenir': 'Souv',
    'Teleportation': 'TP',
    'Spontaneous Return': 'SR',
    'Rewind': 'RW',
    'Reflect': 'RF',
    "Xelor's Punch": 'Punch',
    'Gear': "Gear",
    'Frostbite': 'FB',
    'Disruption': 'Disrupt',
    "Xelor's Sandglass": 'Sandglass',
    'Temporal Distortion': 'Disto',
    'Temporal Dust': 'Dust',
    'Temporal Suspension': 'Susp',
    'Rhol Bak': 'RB',
    'Temporal Instability': 'Instab',
    'Loss of Motivation': 'LOM',
    'Pendulum': 'Pendulum',
    'Temporal Paradox': 'Paradox',
    'Time Rift': 'Rift',
    'Counter': 'Counter',
    'Temporal Oop Shield': 'Shield',
    'Flight': 'Flight',
    'Premonition': 'Premo',
    'Desynchronisation': 'Desync',
    'Knell': 'Knell'
}
    // Translation-related stuff
    // Spell name translation done using the fixed order of spells lists
    const translateXelorSpells = {}
    for (let i=0; i< spellsEN.length; ++i) {
        translateXelorSpells[spellsFR[i]] = spellsEN[i]
    }
    const translateOtherSpells = {}
    for (let i=0; i< otherSpellsEN.length; ++i) {
        translateOtherSpells[otherSpellsFR[i]] = otherSpellsEN[i]
    }
    // Labels are kept here
    const labels = {
        "EN" : {
            "percentAirResLabel" : "% Air Res",
            "fixedAirResLabel" : "&nbsp&nbsp Air Res",
            "meleeResLabel" : "% Melee &nbsp",
            "rangeResLabel" : "&nbsp&nbsp % Range",
            "additionalFixedReductionContainerLabel" : "Fixed Reductions",
            "additionalFinalReductionContainerLabel" : "Final Reductions",
        },
        "FR" : {
            "percentAirResLabel" : "% Res Air",
            "fixedAirResLabel" : "&nbsp&nbsp Res Air",
            "meleeResLabel" : "% Mélée &nbsp",
            "rangeResLabel" : "&nbsp&nbsp % Dist. ",
            "additionalFixedReductionContainerLabel" : "Réductions Dégâts Fixes",
            "additionalFinalReductionContainerLabel" : "Réductions % Finaux",
        }
    }    

    // Globals
    let numberOfBoosts = 0
    let expectedDamage = 0

    let finalFactor = 1
    const activeAdditionalFinalResIDS = []
    let meleeFactor = 1
    let rangeFactor = 1
    let fixedAirRes = 0
    let fixedAdditionalRes = 0
    const activeAdditionalFixedResIDS = []
    let percentAirRes = 0

    let currentLocaleID = "FR"

    const boost = {
        'Slow Down': 0,
        'Teleportation': 0,
        'Rewind': 0,
        "Xelor's Punch": 0,
        'Frostbite': 0,
        "Xelor's Sandglass": 0,
        'Temporal Dust': 0,
        'Rhol Bak': 0,
        'Loss of Motivation': 0,
        'Temporal Paradox': 0,
        'Counter': 0,
        'Flight': 0,
        'Desynchronisation': 0,
    }

    // Functions and Methods
    // Translation
    function cycleLocale() {
        const i = availableLocales.indexOf(currentLocaleID)
        currentLocaleID = availableLocales[(i+1) % availableLocales.length]
        refreshLocalisedText()
    }
    function refreshLocalisedText() {
        const layoutArray = parseLayoutString(layout)
        createSpellGrid(layoutArray)
        fillAdditionalReductionGrids()
        fillLabels()
        const localeCodeNode = document.getElementById("currentLocaleCode")
        localeCodeNode.replaceChildren()
        localeCodeNode.appendChild(document.createTextNode(currentLocaleID))
        const localeImageNode = document.getElementById("currentLocaleImageNode")
        localeImageNode.setAttribute("src", getLocaleImage(currentLocaleID))
    }
    function getLocaleImage(localeID) {
        return localeFlags[localeID]
    }
    function getLabelText(labelID, localeID) {
        return labels[localeID][labelID]
    }
    function fillLabels() {
        for (labelID in labels["EN"]) {
            const labelNode = document.getElementById(labelID)
            labelNode.innerHTML = getLabelText(labelID, currentLocaleID)
        }
    }
    function getLocalisedName(baseSpellName, localeID) {
        const spellID = spellsEN.indexOf(baseSpellName)
        if (spellID === -1) {
            const spellIDTry2 = otherSpellsEN.indexOf(baseSpellName)
            if (spellIDTry2 === -1) {
                throw new Error("Cannot find spell")
                return "ERROR"
            }
            switch(localeID) {
                case "FR" :
                    return otherSpellsFR[spellIDTry2]
                case "EN" :
                    return otherSpellsEN[spellIDTry2]
                default :
                    throw new Error("Unexpected locale ID")
                    return "ERROR"
            }
        }
        switch(localeID) {
            case "FR" :
                return spellsFR[spellID]
            case "EN" :
                return spellsEN[spellID]
            default :
                throw new Error("Unexpected locale ID")
                return "ERROR"
        }
    }
    // utilitary
    function getBaseName(localisedSpellName) {
        return (localisedSpellName in spellsEN) ? localisedSpellName : translateXelorSpells[localisedSpellName]
    }
    function getShortName(spell) {
        return shortName[spell]
    }
    function getVariantOf(spell) {
        return variant[spell] 
    }
    function canTelefrag(spell) {
        return telefrag[spell]
    }
    function getImagePath(spell) {
        return `./images/${spell.replace(/ /g, '_')}.png`
    }
    function extractSpell(string) {
        for (spellName of spellsALLXelor) {
            // try to find the spell's name
            const matchResult = string.match( `^(?<shit> *)(?<spell>${spellName}) ?(?<remaining>.*)$`)
            if (matchResult) {
                return matchResult.groups
            }
            //console.log()
        }
        throw new Error("Unable to extract spell from input string")
    }
    function parseLayoutString(layoutString) {
        const lines = []
        for (let line of layoutString.split("\n")) {
            // Parse line into array of spells that exist
            let remainingString = line
            const spellsFound = []
            while (remainingString.length > 0 ) {
                try {
                const resultOfExtraction = extractSpell(remainingString)
                spellsFound.push(getBaseName(resultOfExtraction.spell))
                remainingString = resultOfExtraction.remaining
                }
                catch (err) {
                    break
                }
            }
            lines.push(spellsFound)
        }
        if (lines[0].length == 0) {lines.shift()}
        if (lines[lines.length-1].length == 0) {lines.pop()}
        return lines
    }
    // functional
    function toggleSpellBoost(spell) {
        if (!canTelefrag(spell)) {return}
        const myNode = document.getElementById(`spellGridItem-${getShortName(spell)}`)
        if (typeof(boost[spell])!=="undefined") {
            // spell is a base spell, use value 1 to signal the base spell is activated
            boost[spell] = (boost[spell]>0) ? 0 : 1
        }
        else {
            // spell is a variant, use value 2 to signal the variant spell is activated
            boost[getVariantOf(spell)] = (boost[getVariantOf(spell)]>0) ? 0 : 2
        }
        updateSpellNodeColor(spell)
        updateExpectedDamage()
    }
    function updateSpellNodeColor(spell) {
        
        const baseSpell = (typeof(boost[spell])!=="undefined") ? spell : getVariantOf(spell)
        const val = boost[baseSpell]
        if (val===1) {
            activateBoostNode(baseSpell)
        }
        else if (val===2) {
            activateBoostNode(getVariantOf(baseSpell))
        }
        else {
            deactivateBoostNode(baseSpell)
        }
    }
    function activateBoostNode(spell) {
        const myNode = document.getElementById(`spellGridItem-${getShortName(spell)}`)
        myNode.style.setProperty("background-color", "#267E08")
        if (canTelefrag(getVariantOf(spell))) {
            document.getElementById(`spellGridItem-${getShortName(getVariantOf(spell))}`).style.setProperty("background-color", "rgba(255,255,255,0.2)")
        }
    }
    function deactivateBoostNode(spell) {
        const myNode = document.getElementById(`spellGridItem-${getShortName(spell)}`)
        // reset background if eligible, also reset for variant if eligible
        if (canTelefrag(spell)) {
            myNode.style.setProperty("background-color", "#757674")
        }
        if (canTelefrag(getVariantOf(spell))) {
            document.getElementById(`spellGridItem-${getShortName(getVariantOf(spell))}`).style.setProperty("background-color", "#757674")
        }
    }
    function createSpellGrid(layout) {
        const spellGridContainerNode = document.getElementById("spellGridContainer")
        spellGridContainerNode.replaceChildren()
        const columns = layout.reduce((maxCol, line) => Math.max(maxCol, line.length), 0)
        const rows = layout.length
        spellGridContainerNode.style.setProperty('grid-template-columns', "1fr ".repeat(columns))
        spellGridContainerNode.style.setProperty('grid-template-rows', "1fr ".repeat(2*rows))
        for (line of layout) {
            const lineA =[]
            const lineB =[]
            for (spell of line) {
                const myImage = document.createElement("input")
                myImage.setAttribute("id",`spellGridItem-${getShortName(spell)}`)
                myImage.setAttribute("title", getLocalisedName(spell, currentLocaleID))
                if (!canTelefrag(spell)) myImage.style.setProperty("background-color", "rgba(0,0,0,0)")
                else myImage.style.setProperty("background-color", "#757674")
                myImage.classList.add("grid-item")
                myImage.setAttribute("type", "image")
                myImage.setAttribute("src", getImagePath(spell))
                myImage.setAttribute("alt", `[ICON : ${getShortName(spell)}]`)
                myImage.setAttribute("onclick", `toggleSpellBoost("${spell}");`)
                lineA.push(myImage)

                const variantSpell = getVariantOf(spell)
                const myVariantImage = document.createElement("input")
                myVariantImage.setAttribute("id",`spellGridItem-${getShortName(variantSpell)}`)
                myVariantImage.setAttribute("title", getLocalisedName(variantSpell, currentLocaleID))
                if (!canTelefrag(variantSpell)) myVariantImage.style.setProperty("background-color", "rgba(0,0,0,0)")
                else myVariantImage.style.setProperty("background-color", "#757674")
                myVariantImage.classList.add("grid-item")
                myVariantImage.setAttribute("type", "image")
                myVariantImage.setAttribute("src", getImagePath(variantSpell))
                myVariantImage.setAttribute("alt", `[ICON : ${getShortName(variantSpell)}]`)
                myVariantImage.setAttribute("onclick", `toggleSpellBoost("${variantSpell}");`)
                lineB.push(myVariantImage)

            }
            for (node of lineA) {
                spellGridContainerNode.appendChild(node)
            }
            for (let i=0; i< columns - lineA.length; ++i) {
                const node = document.createElement("div")
                node.classList.add("grid-item")
                node.style.setProperty("padding","0px")
                node.style.setProperty("border","0px")
                spellGridContainerNode.appendChild(node)
            }
            for (node of lineB) {
                spellGridContainerNode.appendChild(node)
            }
            for (let i=0; i< columns - lineB.length; ++i) {
                const node = document.createElement("div")
                node.classList.add("grid-item")
                node.style.setProperty("padding","0px")
                node.style.setProperty("border","0px")
                spellGridContainerNode.appendChild(node)
            }
            for (spell of line) {
                // we potentially have boosts already on, for this function is also called after a locale change
                updateSpellNodeColor(spell)
            }
        }
    }
    // Fixed Reductions
    function refreshAdditionalFixedReductionNode(nodeID) {
        const myNode = document.getElementById(nodeID)
        if (activeAdditionalFixedResIDS.includes(nodeID)) {
            // Activate
            myNode.style.setProperty("background-color", "#267E08")
        }
        else {
            // Deactivate
            myNode.style.setProperty("background-color", "#757674")
        }
    }
    function toggleAdditionalFixedReduction(nodeID) {
        const myNode = document.getElementById(nodeID)
        if (activeAdditionalFixedResIDS.includes(nodeID)) {
            // Deactivate
            myNode.style.setProperty("background-color", "#757674")
            activeAdditionalFixedResIDS.splice(activeAdditionalFixedResIDS.indexOf(nodeID),1)
            // Fuck you JS, can't even remove an element properly
        }
        else {
            // Activate
            myNode.style.setProperty("background-color", "#267E08")
            activeAdditionalFixedResIDS.push(nodeID)
        }
        updateExpectedDamage()
    }
    function addNewAdditionalFixedReduction() {
        const containerNode = document.getElementById("additionalFixedReductionContainer")
        const width = containerNode.childNodes.length
        const newValue = document.getElementById("additionalFixedReductionItem-CustomInput").value

        // Only work if the new Value is valid (= Number and ParseInt agree on value)
        if (newValue !== "" && Number(newValue)==parseInt(newValue)) {

            // make room for 1 more element on the grid
            containerNode.style.setProperty("grid-template-columns","1fr ".repeat(width +1 ))

            const newNode = document.createElement("div")
            newNode.classList.add("grid-item")
            newNode.setAttribute("id", `additionalFixedReductionItem-${width}`)
            newNode.style.setProperty("background-color", "#757674")

            const newImg = document.createElement("input")
            newImg.setAttribute("type", "image")
            newImg.setAttribute("src", "./images/unknown_shield.png") // Dev Note : Find better icon
            newImg.setAttribute("width", "54px")
            newImg.setAttribute("alt", "[CUSTOM]")
            newImg.setAttribute("title", getLocalisedName("Custom Reduction", currentLocaleID))
            newImg.setAttribute("onclick",`toggleAdditionalFixedReduction("additionalFixedReductionItem-${width}")`)
            newNode.appendChild(newImg)

            const newText = document.createElement("p")
            newText.style.setProperty("color","#EAEBE7")
            newText.style.setProperty("font-size","16px")
            newText.style.setProperty("text-align","center")
            newText.style.setProperty("margin-top","-8px")
            newText.style.setProperty("margin-left","0px")
            newText.style.setProperty("margin-bottom","-4px")

            const newInput = document.createTextNode(newValue)
            newText.appendChild(newInput)

            newNode.appendChild(newText)

            containerNode.insertBefore(newNode, containerNode.childNodes[width-1])
        }
        else {
            console.log("invalid custom fixed reduction, not adding")
        }
    }
    function fillAdditionalFixedReductionGrid() {
        const containerNode = document.getElementById("additionalFixedReductionContainer")
        containerNode.replaceChildren()
        containerNode.style.setProperty("grid-template-columns","1fr ".repeat(FixedReductionBonuses.length +1 ))
        for (i in FixedReductionBonuses) {
            const newNode = document.createElement("div")
            const newNodeID = `additionalFixedReductionItem-${i}`
            newNode.classList.add("grid-item")
            newNode.setAttribute("id", newNodeID)
            // newNode.style.setProperty("background-color", "#757674")

            const newImg = document.createElement("input")
            newImg.setAttribute("type", "image")
            newImg.setAttribute("src", FixedReductionBonuses[i].iconSRC)
            newImg.setAttribute("alt", FixedReductionBonuses[i].alt)
            newImg.setAttribute("title", getLocalisedName(FixedReductionBonuses[i].spellName, currentLocaleID))
            newImg.setAttribute("onclick",`toggleAdditionalFixedReduction("additionalFixedReductionItem-${i}")`)
            newNode.appendChild(newImg)

            const newText = document.createElement("p")
            newText.style.setProperty("color","#EAEBE7")
            newText.style.setProperty("font-size","16px")
            newText.style.setProperty("text-align","center")
            newText.style.setProperty("margin-top","-8px")
            newText.style.setProperty("margin-left","0px")
            newText.style.setProperty("margin-bottom","-4px")
            const t = document.createTextNode(FixedReductionBonuses[i].value)
            newText.appendChild(t)

            newNode.appendChild(newText)

            containerNode.appendChild(newNode)
            refreshAdditionalFixedReductionNode(newNodeID)
        }
        const newNode = document.createElement("div")
        newNode.classList.add("grid-item")
        newNode.setAttribute("id", 'additionalFixedReductionItem-Custom')
        newNode.style.setProperty("background-color", "#757674")

        const newImg = document.createElement("input")
        newImg.setAttribute("type", "image")
        newImg.setAttribute("src", "./images/New.png")
        newImg.setAttribute("width", "54px")
        newImg.setAttribute("alt", "[ADD]")
        newImg.setAttribute("title", getLocalisedName("Add a spell with a custom amount", currentLocaleID))
        newImg.setAttribute("onclick","addNewAdditionalFixedReduction()")
        newNode.appendChild(newImg)

        const newText = document.createElement("div")
        newText.style.setProperty("margin-top","-20px")
        newText.style.setProperty("margin-bottom","-10px")
        const newInput = document.createElement("input")
        newInput.setAttribute("id", 'additionalFixedReductionItem-CustomInput')
        newInput.setAttribute("type","text")
        newInput.style.setProperty("width","30px")
        newText.appendChild(newInput)

        newNode.appendChild(newText)

        containerNode.appendChild(newNode)
    }
    // % Final Reductions
    // Same as fixed (next 4 functions are duplicates of previous 4)
    function refreshAdditionalFinalReductionNode(nodeID) {
        const myNode = document.getElementById(nodeID)
        if (activeAdditionalFinalResIDS.includes(nodeID)) {
            // Activate
            myNode.style.setProperty("background-color", "#267E08")
        }
        else {
            // Deactivate
            myNode.style.setProperty("background-color", "#757674")
        }
    }
    function toggleAdditionalFinalReduction(nodeID) {
        const myNode = document.getElementById(nodeID)
        if (activeAdditionalFinalResIDS.includes(nodeID)) {
            // Deactivate
            myNode.style.setProperty("background-color", "#757674")
            activeAdditionalFinalResIDS.splice(activeAdditionalFinalResIDS.indexOf(nodeID),1)
            // Fuck you JS, can't even remove an element properly
        }
        else {
            // Activate
            myNode.style.setProperty("background-color", "#267E08")
            activeAdditionalFinalResIDS.push(nodeID)
        }
        updateExpectedDamage()
    }
    function addNewAdditionalFinalReduction() {
        const containerNode = document.getElementById("additionalFinalReductionContainer")
        const width = containerNode.childNodes.length
        const newValue = document.getElementById("additionalFinalReductionItem-CustomInput").value

        // Only work if the new Value is valid (= Number and ParseInt agree on value)
        if (newValue !== "" && Number(newValue)==parseInt(newValue)) {

            containerNode.style.setProperty("grid-template-columns","1fr ".repeat(width +1 ))

            const newNode = document.createElement("div")
            newNode.classList.add("grid-item")
            newNode.setAttribute("id", `additionalFinalReductionItem-${width}`)
            newNode.style.setProperty("background-color", "#757674")

            const newImg = document.createElement("input")
            newImg.setAttribute("type", "image")
            newImg.setAttribute("src", "./images/unknown_shield.png") // Dev Note : Find better icon
            newImg.setAttribute("width", "54px")
            newImg.setAttribute("alt", "[CUSTOM]")
            newImg.setAttribute("title", getLocalisedName("Custom Reduction", currentLocaleID))
            newImg.setAttribute("onclick",`toggleAdditionalFinalReduction("additionalFinalReductionItem-${width}")`)
            newNode.appendChild(newImg)

            const newText = document.createElement("p")
            newText.style.setProperty("color","#EAEBE7")
            newText.style.setProperty("font-size","16px")
            newText.style.setProperty("text-align","center")
            newText.style.setProperty("margin-top","-8px")
            newText.style.setProperty("margin-left","0px")
            newText.style.setProperty("margin-bottom","-4px")

            const newInput = document.createTextNode(newValue)
            newText.appendChild(newInput)

            newNode.appendChild(newText)

            containerNode.insertBefore(newNode, containerNode.childNodes[width-1])
        }
        else {
            console.log("invalid custom final reduction, not adding")
        }
    }
    function fillAdditionalFinalReductionGrid() {
        const containerNode = document.getElementById("additionalFinalReductionContainer")
        containerNode.replaceChildren()
        containerNode.style.setProperty("grid-template-columns","1fr ".repeat(FinalReductionBonuses.length +1 ))
        for (i in FinalReductionBonuses) {
            const newNode = document.createElement("div")
            const newNodeID = `additionalFinalReductionItem-${i}`
            newNode.classList.add("grid-item")
            newNode.setAttribute("id", newNodeID)
            // newNode.style.setProperty("background-color", "#757674")

            const newImg = document.createElement("input")
            newImg.setAttribute("type", "image")
            newImg.setAttribute("src", FinalReductionBonuses[i].iconSRC)
            newImg.setAttribute("alt", FinalReductionBonuses[i].alt)
            newImg.setAttribute("title", getLocalisedName(FinalReductionBonuses[i].spellName, currentLocaleID))
            newImg.setAttribute("onclick",`toggleAdditionalFinalReduction("additionalFinalReductionItem-${i}")`)
            newNode.appendChild(newImg)

            const newText = document.createElement("p")
            newText.style.setProperty("color","#EAEBE7")
            newText.style.setProperty("font-size","16px")
            newText.style.setProperty("text-align","center")
            newText.style.setProperty("margin-top","-8px")
            newText.style.setProperty("margin-left","0px")
            newText.style.setProperty("margin-bottom","-4px")
            const t = document.createTextNode(FinalReductionBonuses[i].value)
            newText.appendChild(t)

            newNode.appendChild(newText)

            containerNode.appendChild(newNode)
            refreshAdditionalFinalReductionNode(newNodeID)
        }
        const newNode = document.createElement("div")
        newNode.classList.add("grid-item")
        newNode.setAttribute("id", 'additionalFinalReductionItem-Custom')
        newNode.style.setProperty("background-color", "#757674")

        const newImg = document.createElement("input")
        newImg.setAttribute("type", "image")
        newImg.setAttribute("src", "./images/New.png")
        newImg.setAttribute("width", "54px")
        newImg.setAttribute("alt", "[ADD]")
        newImg.setAttribute("title", getLocalisedName("Add a spell with a custom amount", currentLocaleID))
        newImg.setAttribute("onclick","addNewAdditionalFinalReduction()")
        newNode.appendChild(newImg)

        const newText = document.createElement("div")
        newText.style.setProperty("margin-top","-20px")
        newText.style.setProperty("margin-bottom","-10px")
        const newInput = document.createElement("input")
        newInput.setAttribute("id", 'additionalFinalReductionItem-CustomInput')
        newInput.setAttribute("type","text")
        newInput.style.setProperty("width","30px")
        newText.appendChild(newInput)

        newNode.appendChild(newText)

        containerNode.appendChild(newNode)
    }
    function fillAdditionalReductionGrids() {
        fillAdditionalFixedReductionGrid()
        fillAdditionalFinalReductionGrid()
    }
    function validDamage(floatDamage) {
        return  Math.max(Math.floor(floatDamage),0)
    }
    function recalculateAdditionalFixedRes() {
        let r = 0
        for (nodeID of activeAdditionalFixedResIDS) {
            r += Number(document.getElementById(nodeID).childNodes[1].childNodes[0].textContent)
        }
        fixedAdditionalRes = r
    }
    function recalculateFinalFactor() {
        let factor = 1
        for (nodeID of activeAdditionalFinalResIDS) {
            // take the value, multiply
            factor *= 1-(Number(document.getElementById(nodeID).childNodes[1].childNodes[0].textContent)/100)
        }
        finalFactor = factor
    }
    function recalculateExpectedDamages() {
        // Dégâts=(368-RéFix)x(1-Ré%Air/100)x(1-Ré%Final/100)x(2xNombreBoosts-1)
        refreshAllValues()
        refreshBoosts()
        recalculateFinalFactor()
        recalculateAdditionalFixedRes()
        expectedDamage_melee = validDamage((368 - (fixedAirRes + fixedAdditionalRes)) * (1 - percentAirRes/100) * (finalFactor * meleeFactor) * (2 * numberOfBoosts - 1))
        expectedDamage_range = validDamage((368 - (fixedAirRes + fixedAdditionalRes)) * (1 - percentAirRes/100) * (finalFactor * rangeFactor) * (2 * numberOfBoosts - 1))
    }
    function updateExpectedDamageDisplays() {
        const myNodeM = document.getElementById("expectedDamageNode-Melee")
        myNodeM.textContent = String(expectedDamage_melee)
        const myNodeR = document.getElementById("expectedDamageNode-Range")
        myNodeR.textContent = String(expectedDamage_range)
    }
    function updateExpectedDamage() {
        recalculateExpectedDamages()
        updateExpectedDamageDisplays()
    }
    function refreshBoosts() {
        s = 0
        for (spell in boost) {
            s+= boost[spell] ? 1 : 0
        }
        numberOfBoosts = s
    }
    function refreshMeleeRes() {
        const myNode = document.getElementById("meleeRes")
        meleeFactor = 1 - Number(myNode.value)/100
    }
    function refreshRangeRes() {
        const myNode = document.getElementById("rangeRes")
        rangeFactor = 1 - Number(myNode.value)/100
    }
    function refreshFixedAirRes() {
        const myNode = document.getElementById("fixedAirRes")
        fixedAirRes = Number(myNode.value)
    }
    function refreshPercentAirRes() {
        const myNode = document.getElementById("percentAirRes")
        percentAirRes = Number(myNode.value)
    }

    function refreshAllValues() {
        refreshMeleeRes()
        refreshRangeRes()
        refreshFixedAirRes()
        refreshPercentAirRes()
    }

</script>

<script>
    // Loading and Init
    refreshLocalisedText()
</script>

</html>

